---
title: "Part 1"
author: "Rob Fisk"
date: "21/10/2024"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Here is a very basic skeleton guide to give a sense of what I expect from the assignment. Hopefully this helps. Not sure how much rmarkdown you have been exposed to, but in case you wanted to (learn to) use it, here you go. This pdf is generated from the code I sent, but changing the output in the first few lines to html_document will produce an html file. You can submit pdf, html, or word to moodle and you definitely don't have to use markdown (although it allows you to embed code and therefore avoids having to submit multiple files). Please ask if you aren't sure.

Okay, below would be a perfectly acceptable way to approach the assignment. I like emphasizing the importance of sharing and annotating code. So I hope this is a practice you can adopt. It won't affect your grade, but I do need to be able to follow along so I can see what you did if things dont quite look right. 

Equations may be the challenging part. To write an in-line equation or mathematical symbol, you us single dollar signs ($\sigma$) and an equation on its own line requires double dollar signs:



## Question 1

For continuity and simplicity, I will answer questions a. and b. together, discussing each stage of the dynamics and how these are implemented in R before combining them into a script for the whole model.

First in the BAS model is survival, which can be modelled using a binomial distribution, as there are only two outcomes (survival or death) and the probability is fixed within each age class. A function to implement this takes a population vector and a vector of survival probabilities for each class, phi. 

$$ $$

```{r, eval=FALSE}
survival <- function(pop, phi){
    newpop <- rep(0, length(pop))
    for (i in 1:length(pop)){
        newpop[i] <- rbinom(1, pop[i], phi)
    }
    return(newpop)
}
```

Next comes ageing, which is a deterministic process (all animals age each year) so needs no stochastic component. This process could have been included within the survival code, but for clarity we define it as below, moving each animal forward one age class. 

```{r, eval=FALSE}
ageing <- function(pop){
    newpop <- rep(0, length(pop))
    for (i in 1:(length(pop)-1)){
        newpop[i+1] <- pop[i]
    }
    return(newpop)
}
```

Lastly in the model comes reproduction. As animals in years 2 and 3 give birth to a discrete number of individuals at a rate with constant mean, the poisson distribution is appropriate to use for reproduction. This can be implemented by summing the poisson additions from all adults. You could also generate a single observation from a single combined poisson variable, but I find this the most intuitive way to formulate the code.

$$ $$

```{r, eval=FALSE}
reproduction <- function(pop, rho){
    births <- 0
    for (i in 1:length(pop)){
        births <- births + rpois(1, pop[i]*rho[i])
    }
    pop[1] <- births
    return(pop)
}
```

Finally, once the underlying dynamics have been implemented, we have to add a final stochastic component - detection. There is no double counting and each individual has a fixed probability of being detected or not detected so detection can be implemented using a binomial distribution, in a very similar way to survival earlier.

$$ $$

```{r, eval=FALSE}
detection <- function(pop, p){
    detected <- rep(0, length(pop))
    for (i in 1:length(pop)){
        detected[i] <- rbinom(1, pop[i], p)
    }
    return(detected)
}
```

Now we have defined each component of the model, we can very easily combine them to simulate the dynamics over a number of years, as seen below.

```{r, eval=FALSE}
# putting it all together to observe dynamics
model <- function(N0, phi, rho, p, nyears=25){
    # initialise matrix with n0 and an observation of n0
    pop <- matrix(, nrow=nyears, ncol=length(N0))
    obs <- matrix(, nrow=nyears, ncol=length(N0))
    pop[1,] <- N0
    obs[1,] <- detection(pop[1,], p)

    # simulate forward for year 2+
    for (i in 2:nyears){
        # feeds the population vector through sub-processes
        pop[i,] <- pop[i-1,] |> survival(phi) |> ageing() |> reproduction(rho)

        # generate detected observation
        obs[i,] <- pop[i,] |> detection(p)
    }

    # return results as data frame - more convenient for plotting
    dat <- data.frame(
        year = 1:nyears,
        pop_1 = pop[,1], pop_2 = pop[,2], pop_3 = pop[,3], pop_4 = pop[,4],
        pop_total = rowSums(pop),
        obs_1 = obs[,1], obs_2 = obs[,2], obs_3 = obs[,3], obs_4 = obs[,4],
        obs_total = rowSums(obs)
    )
    return(dat)
}
```

Here we see the huge advantage to this functional approach to the model, as all the subprocesses can be easily applied when simulating forward. This creates a model that could be applied to a variety of similar population dynamics (though the dataframe outputted would have to be adapted to include more age classes). 

To specify our population dynamics and simulate the true and detected populations, we simply need to define the starting population N0; the survival and reproduction rates for each age and the constant detection rate. This is done below to allow the model to be simulated. 

```{r, eval=FALSE}
# parameters as given in the project
n0 <- c(120, 70, 50, 30) # initial population
phi <- c(0.45, 0.7, 0.7, 0.0) # survival rates
rho <- c(0.0, 0.9, 1.9, 0.0) # reproductive rates
p <- 0.5 # detection probability

# simulating one instance of the dynamics
sim <- model(n0, phi, rho, p)
```

- **Simulate and plot 25 years of age-specific population dynamics and observations and produce an informative visualisation of the data.**


